---
title: "Multi-Cohort MLE Casey"
output: html_notebook
---

MLE group cohort model 

## Setup 

```{r}
library(data.table)
library(tidyverse)

source("../gompertz_functions.R")

## read in data
dt <- fread("~/Documents/data/censoc_numident_v2/censoc_numident_v2.csv")

## set seed for reproducibility 
set.seed(1)
```

```{r}
## 1. Write the mll function 

mll.gomp.multicohort.alpha.fe <- function(p, # as many alphas as cohorts, and 1 beta
                                          A) # data matrix with y, u, l, and covariates including cohort
{
  ## (1) get parameters alpha, beta, and B
  ## These will small in number, we'll convert later to one element per individual.
  cohorts = names(table(A$cohort))  ## in data matrix A, each birth year is a name is a cohort
  k <- length(cohorts)
  M = exp(p[1:k]); names(M) = cohorts
  beta = exp(p[k+1])
  ## convert M to alpha
  alpha = getAlpha(M, beta); names(alpha) = cohorts
  
  if(length(p) > k) ## if covariates exist
    B = p[(k+1):length(k)]
  
  ## (2) build rate.vec which has the combined effect of cohort and covariates, 1 element for each indiv
  alpha.vec <- alpha[paste(A$cohort)] ## this is now has one alpha for each individual
  ## (if covariates exist, could do something like next line ...)
  ##     covar_effect.vec <- exp(B * log_wages)
  covar_effect.vec <- 1 ## assume no covariates
  rate.vec = alpha.vec * covar_effect.vec
  y = A$y
  u.vec = A$u
  l.vec = A$l
  
  ## (3) likelihood
  ## Numerator has difference in cumulative probabilities, 1 year apart. This works with data that is
  ## exact to the year of death like we have in CenSoc.
  num = pgompertz(y+1, shape = beta, rate = rate.vec)-
    pgompertz(y, shape = beta, rate = rate.vec)
  denom = pgompertz(u.vec, shape = beta, rate = rate.vec)-
    pgompertz(l.vec, shape = beta, rate = rate.vec)
  R = num/denom
  minusloglik = -sum(log(R))
  return(minusloglik)
}

```


```{r}
# ## 2. Assign values required for mll.gomp.multicohort.alpha.fe function
# 
# ## scalars

 beta_start = 1/10 
# 
# ## vectors
 cohorts = 1910:1919
# first_dyear = 1988  ## if using DMF, change to 1975
# last_dyear = 2005
# uppers <- last_dyear - cohorts
# lowers <- first_dyear - cohorts
# 
# ## identify upper and lower bounds for age at death and modal age at death for each cohort
# # cohrt <- dt[byear == 1911]  ## for each cohort, replace byear and re-run chunk; values go into getEstimates function
# # max(cohrt$death_age)
# # min(cohrt$death_age)
# # Mode(cohrt$death_age)
# 
# modes_true <- c(86, 83, 89, 85, 85, 88, 83, 84, 83, 82)
# 
# names(modes_true) <- cohorts


## 3. Build data matrix A using CenSoc data

# dt = fread("./censoc_dmf_demo_v1/censoc_dmf_demo_v1.csv")  ## demo DMF
# dt <- fread("/data/josh/CenSoc/censoc_data/censoc_numident_v2/censoc_numident_v2.csv")  ## full Numident
# dt <- fread("/data/josh/CenSoc/censoc_data/censoc_dmf_v2/censoc_dmf_v2.csv")  ## full DMF


dt2 <- dt %>% 
  filter(byear %in% 1910:1919) %>% 
  group_by(byear) %>% 
  filter(death_age != min(death_age) & death_age != max(death_age)) %>% 
  mutate(l = min(death_age), u = max(death_age)+ 1) 

  
A <- dt2 %>% 
  ungroup() %>% 
  select(cohort = byear, y = death_age, l, u)
  
A <- A %>% 
  sample_n(100000)

getEstimates <- function()
{    
  ## starting values
  p.start = log(c(rep(80, length(cohorts)),
                  beta_start * .8))
  names(p.start) <- c(paste0("coh", cohorts), "beta")
  
  ## run optimizer
  fit = optim(par = p.start, fn = mll.gomp.multicohort.alpha.fe,
              A = A,
              control = list(maxit = 500))
  
  hat <- round(exp(fit$par), digits = 3)
  
  print(hat)
}

## 4. Generate outputs

# obtain estimates
replicate(1, getEstimates())  ## indicate how many times getEstimates function will loop
```

